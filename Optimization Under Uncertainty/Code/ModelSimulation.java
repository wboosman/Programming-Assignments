import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ilog.concert.IloException;
import ilog.concert.IloNumExpr;
import ilog.concert.IloNumVar;
import ilog.concert.IloNumVarType;
import ilog.cplex.IloCplex;

/**
 * Model class that converts a directed graph representing a precedence
 * constrained knapsack problem into a mathematical programming model managed by
 * CPLEX.
 */

public class ModelSimulation {
	HashMap<String, Double> ArcCap;
	private IloCplex cplex;
	private Map<String, IloNumVar> varMap;
	double[][] distance;
	HashMap<String, double[][]> Amatrices;
	HashMap<String, Double> xValues;
	double[] zValues;

	public ModelSimulation(HashMap<String, Double> ArcCap, HashMap<String, double[][]> Amatrices, double[][] distance,
			HashMap<String, Double> xValues, double[] zValues) throws IloException {
		// Initialize the instance variables
		this.cplex = new IloCplex();
		this.xValues = xValues;
		this.distance = distance;
		this.zValues = zValues;
		this.ArcCap = ArcCap;
		this.Amatrices = Amatrices;
		// Create a map to link items to variables
		this.varMap = new HashMap<>();
		// Initialize the model. It is important to initialize the variables first!
		addVariables();
		addConstraint();
		addObjective();

		// Optionally: export the model to a file, so we can check the mathematical
		// program generated by CPLEX
		cplex.exportModel("modelSimulation.lp");
		// Optionally: suppress the output of CPLEX
		cplex.setOut(null);
	}

	/**
	 * Disable an item in the model (fix it to 0) or enable it (either 0 or 1)
	 * 
	 * @param i       the item to manipulate
	 * @param enabled whether to enable it (0 or 1) or disable it (always 0)
	 * @throws IloException if something is wrong with CPLEX
	 */
	public void setItem() throws IloException {

	}

	/**
	 * Solve the Mathematical Programming Model
	 * 
	 * @throws IloException if something is wrong with CPLEX
	 */
	public void solve() throws IloException {
		cplex.solve();
	}

	/**
	 * Checks whether the current solution to the model is feasible
	 * 
	 * @return the feasibility of the model
	 * @throws IloException if something is wrong with CPLEX
	 */
	public boolean isFeasible() throws IloException {
		return cplex.isPrimalFeasible();
	}

	/**
	 * Create a list of the items for which the decision variables are one in the
	 * current solution of the mathematical program.
	 * 
	 * @return a list of selected items
	 * @throws IloException if something is wrong with CPLEX
	 */
	public List<String> getSolution() throws IloException {
		List<String> answer = new ArrayList<String>();
		for (int i = 0; i < 10; i++) {
			IloNumVar varX = varMap.get("x_" + i);
			answer.add("x_" + i + ": " + cplex.getValue(varX));
		}
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (i != j) {
					IloNumVar varY = varMap.get("y_" + i + "_" + j);
					answer.add("y_" + i + "_" + j + ": " + cplex.getValue(varY));
				}
			}
		}
		return answer;
	}

	public double getObjVal() throws IloException {
		double ans = cplex.getObjValue();
		double sum = 0;
		for (int i = 0; i < 10; i++) {
			sum = sum + xValues.get(i + "");
		}
		return ans + sum;
	}

	/**
	 * Cleans up the CPLEX model in order to free up some memory. This is important
	 * if you create many models, as memory used by CPLEX is not freed up
	 * automatically by the JVM.
	 * 
	 * @throws IloException if something goes wrong with CPLEX
	 */
	public void cleanup() throws IloException {
		cplex.clearModel();
		cplex.end();
	}

	private void addObjective() throws IloException {
		IloNumExpr sum = cplex.constant(0);
		for (int j = 0; j < 10; j++) {
			for (int j2 = 0; j2 < 10; j2++) {
				IloNumExpr sum2 = cplex.constant(0);
				IloNumVar varY = varMap.get("y_" + j + "_" + j2);
				sum2 = cplex.sum(sum2, distance[j][j2]);
				sum2 = cplex.prod(varY, sum2);
				sum = cplex.sum(sum2, sum);
			}
		}
		cplex.addMinimize(sum);
	}

	private void addConstraint() throws IloException {
		for (int loc = 0; loc < 10; loc++) {
			IloNumExpr sum = cplex.constant(0);

			sum = cplex.sum(sum, xValues.get(loc + ""));

			int counter = 10;
			for (int j = 0; j < 10; j++) {
				for (int j2 = 0; j2 < 10; j2++) {
					IloNumExpr sum2 = cplex.constant(0);
					IloNumVar varY = varMap.get("y_" + j + "_" + j2);
					sum2 = cplex.sum(sum2, Amatrices.get(loc + "")[0][counter]);
					sum2 = cplex.prod(varY, sum2);
					sum = cplex.sum(sum2, sum);
					counter++;
				}
			}
			cplex.addGe(sum, zValues[loc]);
		}
	}

	private void addVariables() throws IloException {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (ArcCap.containsKey((i + 1) + " " + (j + 1))) {
					IloNumVar varY = cplex.numVar(0, ArcCap.get((i + 1) + " " + (j + 1)), IloNumVarType.Float,
							"y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				} else if (ArcCap.containsKey((j + 1) + " " + (i + 1))) {
					IloNumVar varY = cplex.numVar(0, ArcCap.get((j + 1) + " " + (i + 1)), IloNumVarType.Float,
							"y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				} else {
					IloNumVar varY = cplex.numVar(0, -1, IloNumVarType.Float, "y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				}
			}
		}
	}
}

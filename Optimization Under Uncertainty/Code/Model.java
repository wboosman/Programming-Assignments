import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ilog.concert.IloException;
import ilog.concert.IloNumExpr;
import ilog.concert.IloNumVar;
import ilog.concert.IloNumVarType;
import ilog.cplex.IloCplex;

/**
 * Model class that converts a directed graph representing a precedence
 * constrained knapsack problem into a mathematical programming model managed by
 * CPLEX.
 * 
 */

public class Model {
	HashMap<String, Double> ArcCap;
	private IloCplex cplex;
	private Map<String, IloNumVar> varMap;
	private double[] mean;
	private double[] stDev;
	double[][] distance;
	double normal;
	HashMap<String, double[][]> Amatrices;

	public Model(HashMap<String, Double> ArcCap, double[] mean, double[] stDev, HashMap<String, double[][]> Amatrices,
			double[][] distance, double normal) throws IloException {
		// Initialize the instance variables
		this.cplex = new IloCplex();
		this.distance = distance;
		this.stDev = stDev;
		this.normal = normal;
		this.ArcCap = ArcCap;
		this.mean = mean;
		this.Amatrices = Amatrices;
		// Create a map to link items to variables
		this.varMap = new HashMap<>();
		// Initialize the model. It is important to initialize the variables first!
		addVariables();
		addConstraint();
		addObjective();

		// Optionally: export the model to a file, so we can check the mathematical
		// program generated by CPLEX
		cplex.exportModel("model.lp");
		// Optionally: suppress the output of CPLEX
		cplex.setOut(null);
	}

	/**
	 * Disable an item in the model (fix it to 0) or enable it (either 0 or 1)
	 * 
	 * @param i       the item to manipulate
	 * @param enabled whether to enable it (0 or 1) or disable it (always 0)
	 * @throws IloException if something is wrong with CPLEX
	 */
	public void setItem() throws IloException {

	}

	/**
	 * Solve the Mathematical Programming Model
	 * 
	 * @throws IloException if something is wrong with CPLEX
	 */
	public void solve() throws IloException {
		cplex.solve();
	}

	/**
	 * Checks whether the current solution to the model is feasible
	 * 
	 * @return the feasibility of the model
	 * @throws IloException if something is wrong with CPLEX
	 */
	public boolean isFeasible() throws IloException {
		return cplex.isPrimalFeasible();
	}

	/**
	 * Create a list of the items for which the decision variables are one in the
	 * current solution of the mathematical program.
	 * 
	 * @return a list of selected items
	 * @throws IloException if something is wrong with CPLEX
	 */
	public List<String> getSolution() throws IloException {
		List<String> answer = new ArrayList<String>();
		for (int i = 0; i < 10; i++) {
			IloNumVar varX = varMap.get("x_" + i);
			answer.add("x_" + i + ": " + cplex.getValue(varX));
		}
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (i != j) {
					IloNumVar varY = varMap.get("y_" + i + "_" + j);
					answer.add("y_" + i + "_" + j + ": " + cplex.getValue(varY));
				}
			}
		}
		return answer;
	}

	public HashMap<String, Double> getxValues() throws IloException {
		HashMap<String, Double> xValues = new HashMap<String, Double>();
		for (int i = 0; i < 10; i++) {
			IloNumVar varX = varMap.get("x_" + i);
			xValues.put(i + "", cplex.getValue(varX));
		}
		return xValues;
	}

	public double getObjVal() throws IloException {
		return cplex.getObjValue();
	}

	/**
	 * Cleans up the CPLEX model in order to free up some memory. This is important
	 * if you create many models, as memory used by CPLEX is not freed up
	 * automatically by the JVM.
	 * 
	 * @throws IloException if something goes wrong with CPLEX
	 */
	public void cleanup() throws IloException {
		cplex.clearModel();
		cplex.end();
	}

	private void addObjective() throws IloException {
		IloNumExpr sum = cplex.constant(0);
		for (int i = 0; i < 10; i++) {
			IloNumExpr sum2 = cplex.constant(1);
			IloNumVar varX = varMap.get("x_" + i);
			sum2 = cplex.prod(varX, sum2);
			sum = cplex.sum(sum2, sum);
		}
		for (int j = 0; j < 10; j++) {
			for (int j2 = 0; j2 < 10; j2++) {
				IloNumExpr sum2 = cplex.constant(0);
				IloNumVar varY = varMap.get("y_" + j + "_" + j2);
				sum2 = cplex.sum(sum2, distance[j][j2]);
				sum2 = cplex.prod(varY, sum2);
				sum = cplex.sum(sum2, sum);
			}
		}
		cplex.addMinimize(sum);

	}

	private void addConstraint() throws IloException {
		for (int loc = 0; loc < 10; loc++) {
			// Voor elke locatie constraint toevoegen, loop over heel vector x, dus 10 loop
			// + 10*10 loop
			IloNumExpr sum = cplex.constant(0);
			for (int i = 0; i < 10; i++) {
				IloNumExpr sum2 = cplex.constant(0);
				IloNumVar varX = varMap.get("x_" + i);
				sum2 = cplex.sum(sum2, Amatrices.get(loc + "")[0][i]);
				sum2 = cplex.prod(varX, sum2);
				sum = cplex.sum(sum2, sum);
			}
			int counter = 10;
			for (int j = 0; j < 10; j++) {
				for (int j2 = 0; j2 < 10; j2++) {
					IloNumExpr sum2 = cplex.constant(0);
					IloNumVar varY = varMap.get("y_" + j + "_" + j2);
					sum2 = cplex.sum(sum2, Amatrices.get(loc + "")[0][counter]);
					sum2 = cplex.prod(varY, sum2);
					sum = cplex.sum(sum2, sum);
					counter++;
				}
			}
			sum = cplex.diff(sum, mean[loc]);
			sum = cplex.prod(sum, 1 / stDev[loc]);
			cplex.addGe(sum, normal);
		}

	}

	public static double[] multiply(double[][] matrix, double[] vector) {
		int rows = matrix.length;
		int columns = matrix[0].length;

		double[] result = new double[rows];

		for (int row = 0; row < rows; row++) {
			double sum = 0;
			for (int column = 0; column < columns; column++) {
				sum += matrix[row][column] * vector[column];
			}
			result[row] = sum;
		}
		return result;
	}

	private void addVariables() throws IloException {
		for (int i = 0; i < 10; i++) {
			IloNumVar varX = cplex.numVar(0, 20.0, IloNumVarType.Float, "x_" + i);
			varMap.put("x_" + i, varX);
		}
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (ArcCap.containsKey((i + 1) + " " + (j + 1))) {
					IloNumVar varY = cplex.numVar(0, ArcCap.get((i + 1) + " " + (j + 1)), IloNumVarType.Float,
							"y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				} else if (ArcCap.containsKey((j + 1) + " " + (i + 1))) {
					IloNumVar varY = cplex.numVar(0, ArcCap.get((j + 1) + " " + (i + 1)), IloNumVarType.Float,
							"y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				} else {
					IloNumVar varY = cplex.numVar(0, -1, IloNumVarType.Float, "y_" + i + "_" + j);
					varMap.put("y_" + i + "_" + j, varY);
				}
			}
		}
	}
}
